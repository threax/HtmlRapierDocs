<!doctype html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reference</title>
    <link rel="stylesheet" href="/HtmlRapierDocs/lib/bootstrap/dist/css/bootstrap-custom.css?linkver=20210106055756" type="text/css">

</head>

<body>
    <nav class="navbar navbar-dark bg-dark fixed-top" data-hr-run="edity.theme.layouts.default">
        <button class="navbar-toggler" type="button" data-target="#wrapper" data-toggle="sidebar" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        <a class="navbar-brand" href="/HtmlRapierDocs/">HtmlRapier Docs</a>
    </nav>

    <div class="navbar-shadow-short"></div>
    <div class="navbar-spacer-short"></div>

    <div id="wrapper">
        <!-- Sidebar -->
        <div id="sidebar-wrapper" class="sidebar-with-navbar-short">
            <div class="mainTreeMenu" data-hr-controller="treeMenu" data-hr-config-urlroot="/HtmlRapierDocs/" data-hr-config-menu="/HtmlRapierDocs/menus/mainMenu.json" data-hr-config-scrollelement="#sidebar-wrapper" data-hr-model-component="sidebarMenuComponent" data-hr-config-treemenu-version="4F6E7F3056BA8BC8777BC866D2E04D0331530E5DFBE6BD561E47BFC3F4EDDF92">
                <ul class="sidebarMenu" data-hr-model="childItems" data-hr-model-component="sidebarMenuComponent">
                    <template data-hr-component="sidebarMenuComponent">
                        <li class="folder">
                            <div class="item" data-hr-on-click="toggleMenuItem" data-hr-toggle="current" data-hr-class-on="currentFolder"><span data-hr-toggle="children" class="glyphicon" data-hr-class-on="glyphicon-folder-open" data-hr-class-off="glyphicon-folder-close"></span> {{name}}</div>
                            <div class="children" data-hr-model="children" data-hr-model-component="sidebarMenuComponent" data-hr-toggle="children" data-hr-class-on="expanded" data-hr-style-off="display:none;"></div>
                        </li>
                    </template>
                    <template data-hr-variant="link">
                        <li class="link">
                            <a href="{{urlRoot}}{{link}}" target="{{target}}">
                                <div class="mainBlock" data-hr-toggle="current" data-hr-class-on="currentLink">
                                    {{name}}
                                </div>
                            </a>
                        </li>
                    </template>
                    <template data-hr-variant="root">
                        <div class="children" data-hr-model="children" data-hr-model-component="sidebarMenuComponent" data-hr-toggle="children" data-hr-class-on="expanded" data-hr-style-off="display:none;"></div>
                    </template>
                </ul>
            </div>
        </div>

        <!-- Page Content -->
        <div id="page-content-wrapper">
            <div class="container">
                <div class="row">
                    <div class="col-md-12 pageContent">
                        <h3 id="DataAttributes">Data Attributes</h3>
<p>At its heart this library is a fancy way of labeling elements on a html page with some attributes that make extracting them later, with some special properties, easier. You can define the following types of attributes on your elements.</p>
<ul>
	<li><strong>Controller </strong>- <code><samp><font face="Courier New">data-hr-controller=&quot;<em>controllerName</em>&quot;</font></samp></code> - This defines the primary interface between your&nbsp;javascript and&nbsp;the&nbsp;markup and act as more or less of an entry point for everything else. The <em>controllerName&nbsp;</em>value defines the name of the controller.</li>
	<li><strong>Event<strong> </strong></strong>-<strong> </strong><code><font face="Courier New">data-hr-on-<em>eventName</em>=&quot;<em>functionName</em>&quot;</font></code><em> - </em>Bind the element event <em>eventName </em>to the function in your controller named <em>functionName</em>.</li>
	<li><strong>Config</strong> - <code><font face="Courier New">data-hr-config-<em>name</em>=&quot;<em>value</em>&quot;</font></code> - Create&nbsp;a configuration for the controller named <em>name </em>with the value <em>value</em>.</li>
	<li><strong>Toggle</strong> - <code><font face="Courier New">data-hr-toggle=&quot;<em>name</em>&quot;</font></code> - Create a toggle named name. Toggles abstract the dom from your javascript for things like styles and classes. Toggles can be set&nbsp;to on and off in your javascript code.&nbsp;You can use the following attributes to in addition to a data-hr-toggle on an element to control what it looks like when the toggle is on and off.
	<ul>
		<li><strong>On Styles</strong> -<strong> </strong><code><font face="Courier New">data-hr-style-on=&quot;<em>styleList</em>&quot;</font></code> - Apply the styles in <em>styleList </em>when this toggle is on.</li>
		<li><strong>Off Styles</strong> - <code><font face="Courier New">data-hr-style-off=&quot;<em>styleList</em>&quot;</font></code> - Apply the styles in <em>styleList </em>when this toggle is off.</li>
		<li><strong>On Classes</strong> - <code><font face="Courier New">data-hr-class-on=&quot;<em>classList</em>&quot;</font></code> - Apply the classes in <em>classList </em>when this toggle is on.</li>
		<li><strong>Off Classes</strong> - <code><font face="Courier New">data-hr-class-off=&quot;<em>classList</em>&quot;</font></code> - Apply the classes in <em>classList </em>when this toggle is off.</li>
		<li><strong>Idle Classes</strong> - <code><font face="Courier New">data-hr-class-idle=&quot;<em>classList</em>&quot;</font></code> - Apply <em>classList </em>classes when the animations on this element have completed. HtmlRapier can track animation states when you toggle and will apply this class after the animations are completed.</li>
	</ul></li>
	<li><strong>Model </strong>- <code><font face="Courier New">data-hr-model=&quot;<em>name</em>&quot;</font></code> - Create a model on the specified element named <em>name</em>. Models define functions for getData, setData, appendData, getSrc and clear. Even though most models support a getData function, they will not do anything except return a blank object unless you have&nbsp;a&nbsp;FormModel, in which&nbsp;case you will get the form&#39;s data. A model, if it is able, will automatically repeat&nbsp;collection data that it is passed, otherwise it outputs a single element.&nbsp;All models will escape their output for malicious html, so you don&#39;t need to scrub your data yourself. Depending on what kind of element you attach this to you will get different models:
	<ul>
		<li><strong>FormModel</strong> - This model is created if this attribute is added to a form element. Form models can get and set a single piece of data using getData and setData. This is the only model that returns something useful from getData, which is the current data on the form as a plain javascript object.</li>
		<li><strong>ComponentModel</strong> - This model is created when the data-hr-model attribute is added to a node that also has data-hr-component on it (or will get one from an anonymous template). It will use a template that you define to output the data you specify. If the data is a collection then you will get repeated elements. This is the most flexible kind of model. To get this kind of model add a <code><font face="Courier New">data-hr-component=&quot;name&quot;</font></code> attribute to it or define a template as its child, which will make an anonymous template, which has the same effect.</li>
		<li><strong>TextNodeModel </strong>-&nbsp;With no special conditions a TextNodeModel is created. This will look for variables defined like {{varName}} and fill them in with matching data on the object bound to this model.</li>
		<li>Finally you can configure the source string for a model with the <code><font face="Courier New">data-hr-model-src=&quot;<em>value</em>&quot;</font></code> attribute.</li>
	</ul></li>
	<li><strong>Component</strong> -&nbsp;<code><font face="Courier New">&lt;template data-hr-component=&quot;<em>name</em>&quot;&gt;<em>markup</em>&lt;/template&gt;</font></code> - Create a component named <em>name</em> with the&nbsp;html code&nbsp;<em>markup</em>. Components must be &lt;template&gt; elements. You can actually omit the <code><font face="Courier New">data-hr-component=&quot;name&quot;</font></code> attribute if you are creating the component as a direct descendant of a model node, which creates an anonymous template that gets its name assigned at runtime. This makes labeling components to their models much simpler since you don&#39;t have to come up with a ton of unique names, however, sometimes you will need to specify the names directly and you can do this here.
	<ul>
		<li><strong>Variant </strong>- <code><font face="Courier New">&lt;template data-hr-component=&quot;componentName&quot;&nbsp;data-hr-variant=&quot;<em>name</em>&quot;&gt;<em>markup</em>&lt;/template&gt;</font></code> - This will specify a variant of a template. Variants allow you to have different verisons of a component depending on your source data. You will define a function when binding data to a model that returns the name of the variant to use for a component. Variant names must be unique for each component, but can be repeated otherwise. You can omit the data-hr-component part if you are creating this variant as part of a variant chain. To do this create your first template element, either anonymous or with a name. Next as the immediate sibling to that first &lt;template&gt; element create another with the data-hr-variant attribute and give it a variant name. This will attach the 2nd template as a variant on the first. This chain will continue until there are no more siblings or another element type is encountered.</li>
	</ul></li>
	<li><strong>Handle</strong> - <code>data-hr-handle</code> - Get direct access to the HtmlElement pointed to by the named handle. Mostly useful to pass elements into third party libraries that want them, otherwise should be avoided as much as possible.</li>
	<li><strong>Ignore </strong>- <code><font face="Courier New">data-hr-ignored</font></code> - Add this to an element to ignore any components and controllers it has as children. This is mostly a special case to handle editors where you still need to run other&nbsp;HtmlRapier code.</li>
</ul>
<h3 id="JavascriptFunctions">Javascript Functions</h3>
<p>Beyond its features for html the library defines a couple other classes and concepts that you can use.</p>
<h4>JSNS</h4>
<p>Jsns is the core of htmlrapier in terms of how it deals with files. This stands for Javascript Namespace and it allows you an easy way to define javascript libraries that can be shared across files, loaded in any order and either bundled + minified or as separate files (or a mixture). It does a better job of handling the reality of web development better than browserify that crams everything into one file and avoids the issues and partial deprecation of AMD. It can be thought of as a hybrid to those&nbsp;2 approaches that does not define anything about how the javascript gets on&nbsp;the page.&nbsp;It also tries to optimize a little bit by only loading the moduels that it needs. This way you can have a larger core shared library of javascript that is minified into one file with individual pages using their own separate javascript files that can plug into the rest of the system. This enables the sharing and chacing of core code resources between requests. It is also possible to load javascript using the async keyword with this system as long as the jsns.js contents have loaded.</p>
<p>Jsns tries to emulate the node.js way of packaging things up. If you are using libraries that detect their environment wrapping them up on a jsns factory method should make them export correctly without any modifications. You can then import that module the standard way.</p>
<p>If you use no other features from this library, at least use jsns.js. It helps a great deal for code organization.</p>
<p>The class exposes 2 important functions:</p>
<ol>
	<li><strong>Define </strong>- <code><font face="Courier New">jsns.define(name, dependencies, factory)</font></code>&nbsp;- Define a module in the system. These will never run unless they are needed by something else, then the factory function will be called to create the module and its exports. A boilerplate example of a define function call looks like the following:
	<pre style="margin: 0px; line-height: 125%;"><span style="background-color: rgb(255, 240, 240);">&quot;use strict&quot;</span>;

jsns.define(<span style="background-color: rgb(255, 240, 240);">&quot;my.name&quot;</span>, [
    
],
<span style="color: rgb(0, 136, 0); font-weight: bold;">function</span>(exports, module){
    
});</pre>Here we define a module named my.name, with no dependencies that defines nothing in its factory method. To specify dependencies list them in the array and add them as arguments to the factory function. The system will inject the libraries it finds for each dependency into the arguments to this function that come after module.
	<br>
	<br>To get a better idea of how this works look at the first few lines from controller.js.
	<pre style="margin: 0px; line-height: 125%;"><span style="background-color: rgb(255, 240, 240);">&quot;use strict&quot;</span>;

jsns.define(<span style="background-color: rgb(255, 240, 240);">&quot;hr.controller&quot;</span>, [
    <span style="background-color: rgb(255, 240, 240);">&quot;hr.bindingcollection&quot;</span>,
    <span style="background-color: rgb(255, 240, 240);">&quot;hr.domquery&quot;</span>,
    <span style="background-color: rgb(255, 240, 240);">&quot;hr.ignored&quot;</span>,
],
<span style="color: rgb(0, 136, 0); font-weight: bold;">function</span> (exports, module, BindingCollection, domQuery, ignoredNodes) {</pre>Here we define 3 dependencies and take them as arguments to the factory function.
	<br>&nbsp;</li>
	<li><strong>Run </strong>- <code><font face="Courier New">jsns.run(dependencies, factory)</font></code>&nbsp;- Run a module. Calling run with a factory function is what makes the jsns system start to actually do something. If all you do is define a bunch of stuff but never run anything, nothing will happen on your page. So you want to have at least one thing that runs per page. This will probably be what defines and activates your controllers. The factory functions passed in will not actually run until all of the dependencies have loaded. Remember the order does not matter after jsns.js is included. You can define a runner that uses HtmlRapier classes and then later include the HtmlRapier library itself. Once those dependencies have loaded the runner will run. Runners are run in the order they are added to jsns or once all their dependencies have loaded, whichever comes first.</li>
</ol>
<h4>Events</h4>
<p>In addition to standard browser events HtmlRapier defines some pure javascript events that can be used to synchronize code without involving the browser. There are 3 variations defined in the events.js file.</p>
<ol>
	<li><strong>EventHandler </strong>- <code><font face="Courier New">hr.eventhandler</font></code> - A simple event handler. Add and remove listeners (and a context to act as this) and fire an event to those listeners. You can pass arguments by passing them when you call fire. These will be passed to all of your event listeners. You might want to define a standard for a particular EventHandler instance&#39;s listener functions, but javascript does not really enforce anything (which works out well here).</li>
	<li><strong>LateBoundEventHandler&nbsp;</strong>- <code><font face="Courier New">hr.lateboundeventhandler</font></code> - The same as EventHandler, but will queue up all fire methods until the first listener is added. This makes it easy to handle events where you might miss something fired off before you have had the chance to load. Once the first listener is bound this works like a normal EventHandler and&nbsp;no longer queues events. This also means that the&nbsp;2nd listener added to this event will not get&nbsp;the queued events.&nbsp;Likely more rare to use than EventHandler, but helpful in certain situations.</li>
	<li><strong>PromiseEventHandler </strong>- <code><font face="Courier New">hr.promiseeventhandler</font></code> - Works like a normal event handler, but when fired will return a promise that will wait for all fired events to complete. This makes it easier to synchronize events when they use async code since the master event promise won&#39;t fulfil until any sub promises returned by the listeners have fired.</li>
</ol>
<h4>Http</h4>
<p>There is also a simple http module that lets you do get, post, put and delete with&nbsp;plain javascript objects. These functions will return promises that will fill with the server data. This module also exposes an ajax function for more raw calls and a upload function to simplify sending a file.</p>
<h4>Storage</h4>
<p>This provides an easy interface to the session storage in the browser. This will take plain javascript objects and serialize them to/from json when they are being saved.</p>
<h4>Toggles</h4>
<p>Toggles are discussed as part of the html section, since that handles most of the work, however, if you import the toggles module you can do a couple extra things.</p>
<ol>
	<li>Define Toggle groups to activate and deactivate sets of toggles more easily.
	<pre style="margin: 0px; line-height: 125%;"><span style="color: rgb(0, 136, 0); font-weight: bold;">var</span> load <span style="color: rgb(51, 51, 51);">=</span> bindings.getToggle(<span style="background-color: rgb(255, 240, 240);">&#39;load&#39;</span>);
<span style="color: rgb(0, 136, 0); font-weight: bold;">var</span> main <span style="color: rgb(51, 51, 51);">=</span> bindings.getToggle(<span style="background-color: rgb(255, 240, 240);">&#39;main&#39;</span>);
<span style="color: rgb(0, 136, 0); font-weight: bold;">var</span> fail <span style="color: rgb(51, 51, 51);">=</span> bindings.getToggle(<span style="background-color: rgb(255, 240, 240);">&#39;fail&#39;</span>);
<span style="color: rgb(0, 136, 0); font-weight: bold;">var</span> toggler <span style="color: rgb(51, 51, 51);">=</span> <span style="color: rgb(0, 136, 0); font-weight: bold;">new</span> toggles.Group(load, main, fail);
toggler.activate(load);</pre>Here 3 toggles are added to a group. Then the toggler is told to activate the load toggle. This will turn the main and fail toggles to off and the load toggle to on.</li>
	<li>Extend toggles with new types. You can use the addTogglePlugin function in this module to add a listener that is called when a toggle is being created. This was used to make bootstrap modals work over toggles if the toggle is attached to an item that has the class toggle on it. Toggles build chains of all possible actions when they are created, so if you use a class on attribute with a style on and off the class and style will be applied on on and only the off style will be applied on off.</li>
</ol>
<h3 id="OtherPatterns">Other Patterns</h3>
<h4>Services</h4>
<p>This library has no concrete concept of services or how you should make them (or indeed if you should make them at all). However, it is reccomended for any advanced server communication to create a module likely with service in its name that accesses the server and does work. You can also put events in them like loadStarted, loadComplete that can easily be bound to ui elements to make work more visible.</p>
<h4>Promises</h4>
<p>Promises are used whenever possible for async code. The chaining and error handling they provide fit in very well with this library. HtmlRapier also includes a promise polyfill so you can use them on IE and other browsers that don&#39;t support them natively.</p>
<h3>Security</h3>
<h4>Anti&nbsp;Cross Site Request Forgery (CSRF)</h4>
<p>The library includes some features to help prevent cross site request forgery (CSRF) attacks. These are located in <code>hr.anticsrf</code>, which exposes one funciton getToken(url). This function takes the url of an endpoint to POST to&nbsp;that returns a JSON object that contains 2 properties:</p>
<ol>
	<li><strong>HeaderName</strong> - The name of the header to set when sending the token back to the server.</li>
	<li><strong>RequestToken</strong>.- The token to use to validate requests.</li>
</ol>
<p>Once this is activated and the token is downloaded it will be automatically included in any requests run through <code>hr.http</code>that connect to the domain specified by url. So if you get a token from <a href="http://www.example.com/Auth/AuthToken">www.example.com/Auth/AuthToken</a>&nbsp;any requests to <a href="http://www.example.com">www.example.com</a> will add the CSRF token to the header.</p>
<p><strong>A note about order of operations:</strong> Any requests made after a call to getToken for a given domain will be delayed until the token has been recovered. If a request is made before a call to getToken the system will not know about the desire for csrf protection and none will be used. So in short, don&#39;t start making requests to a domain that needs csrf before calling getToken to setup the csrf protection token.</p>
<p><strong>A note about security and CORS:</strong> This technique relies on an attacker not being able to visit the url you use to get tokens using javascript from the victim&#39;s browser due to the same origin policy. If you are getting a token from the same domain there is no problem, but if you are using CORS to access an api on another domain that violates the Same Origin Policy you must be sure than an attacker website cannot read data from the endpoint url. This means properly setting up CORS for an api based service to only whitelist the sites that need to access the api. If you use a * the protections offered by this library will not work. In that case the attacker can do his own version of getToken(url), get the antiforgery token and include it with malicious requests back to the server.</p>
<p>If you didnt read the above, <strong>using a * for your CORS policy will make these protections useless</strong>, since an attacker can get your antiforgery token and use it at will.</p>
                        <div class="footer"></div>
                    </div>
                </div>
                <div class="footer-padding"></div>
            </div>
        </div>
    </div>
    <script type="text/javascript" src="/HtmlRapierDocs/lib/tslib.js?linkver=20210106055756"></script>
<script type="text/javascript" src="/HtmlRapierDocs/lib/jquery/dist/jquery.min.js?linkver=20210106055756"></script>
<script type="text/javascript" src="/HtmlRapierDocs/lib/popper.js/dist/popper.min.js?linkver=20210106055756"></script>
<script type="text/javascript" src="/HtmlRapierDocs/lib/bootstrap/dist/js/bootstrap.min.js?linkver=20210106055756"></script>
<script type="text/javascript" src="/HtmlRapierDocs/lib/tsbin.prod.js?linkver=20210106055756"></script>
<script type="text/javascript" src="/HtmlRapierDocs/lib/hr-run.js?linkver=20210106055756"></script>

</body>

</html>